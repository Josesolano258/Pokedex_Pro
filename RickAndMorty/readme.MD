# ğŸ›¸ Explorador Rick and Morty

AplicaciÃ³n web que consume la API de **Rick and Morty** para buscar y filtrar personajes.

---

## ğŸš€ Funcionalidades

âœ… Mostrar personajes desde la API  
âœ… Buscar por nombre  
âœ… Filtrar por estado  
âœ… Filtrar por especie  
âœ… Loader mientras cargan datos  
âœ… PaginaciÃ³n (Anterior / Siguiente)  
âœ… Manejo de errores  

---

## ğŸ§  Conceptos Clave (modo examen)

Este proyecto utiliza:

- **HTML** â†’ estructura
- **CSS** â†’ estilos
- **JavaScript** â†’ lÃ³gica
- **Fetch API** â†’ peticiones HTTP
- **Async / Await** â†’ asincronÃ­a
- **DOM Manipulation** â†’ actualizar interfaz

---

## ğŸ“‚ Estructura del Proyecto


/proyecto
â”œâ”€â”€ index.html
â”œâ”€â”€ Rick.css
â”œâ”€â”€ Rick.js


---

## ğŸ–¥ï¸ HTML â€“ Elementos importantes

### ğŸ” Input de bÃºsqueda

```html
<input type="text" id="name" placeholder="Buscar por nombre">

âœ” Permite escribir el nombre del personaje
âœ” JS obtiene su valor con:

const name = nameInput.value.trim();
ğŸ¯ Selectores (Filtros)
<select id="status">
<select id="species">

âœ” Permiten filtrar resultados
âœ” .value devuelve opciÃ³n seleccionada

Ejemplo:

const status = statusSelect.value;
ğŸ”˜ Botones
BotÃ³n	FunciÃ³n
Buscar	Ejecuta consulta
Limpiar	Resetea filtros
Anterior	PÃ¡gina previa
Siguiente	PÃ¡gina siguiente

Ejemplo evento:

searchBtn.addEventListener("click", () => {
  fetchCharacters(1);
});
ğŸŒ Consumo de API (Fetch)
PeticiÃ³n bÃ¡sica
const response = await fetch(url);
const data = await response.json();

âœ” fetch() â†’ llama API
âœ” await â†’ espera respuesta
âœ” .json() â†’ convierte datos

Manejo de errores
if (!response.ok) {
  throw new Error("No se encontraron personajes");
}

âœ” Detecta errores HTTP (404, etc)

ğŸ”„ Async / Await

Permite escribir cÃ³digo asincrÃ³nico como si fuera sÃ­ncrono.

async function fetchCharacters() {
  const response = await fetch(url);
}
ğŸ§© ConstrucciÃ³n de URL dinÃ¡mica
const url = new URL('https://rickandmortyapi.com/api/character');
url.searchParams.append('page', page);

âœ” Evita concatenar strings manualmente
âœ” MÃ¡s limpio y seguro

Agregar filtros:

if (name) url.searchParams.append('name', name);
ğŸ¨ Renderizado dinÃ¡mico (map)
result.innerHTML = characters.map(character => `
  <div class="card">
    <h3>${character.name}</h3>
  </div>
`).join('');

âœ” map() recorre array
âœ” Genera HTML dinÃ¡mico

â³ Loader (Spinner)

Mostrar:

loader.classList.remove("hidden");

Ocultar:

loader.classList.add("hidden");

âœ” Feedback visual al usuario

ğŸ“„ PaginaciÃ³n

Variables de control:

let currentPage = 1;
let totalPages = 1;

Actualizar botones:

prevBtn.disabled = currentPage === 1;
nextBtn.disabled = currentPage === totalPages;
ğŸ§¹ Limpiar Filtros
nameInput.value = "";
statusSelect.value = "";
speciesSelect.value = "";

âœ” Resetea UI

âš ï¸ Manejo de errores UI
catch (error) {
  result.innerHTML = `<p>${error.message}</p>`;
}

âœ” Evita pantalla vacÃ­a

âœ… Buenas prÃ¡cticas aplicadas

âœ” Script al final del <body>
âœ” try / catch / finally
âœ” URLSearchParams
âœ” SeparaciÃ³n HTML / CSS / JS
âœ” Variables de estado

ğŸ§  Posibles preguntas de examen

â“ Â¿QuÃ© hace fetch()?
Hace peticiones HTTP a APIs.

â“ Diferencia entre .then() y await?
await es sintaxis mÃ¡s limpia sobre Promises.

â“ Para quÃ© sirve map()?
Transformar arrays (ej: datos â†’ HTML).

â“ QuÃ© hace trim()?
Elimina espacios al inicio/final.

â“ QuÃ© significa response.ok?
Indica si la respuesta HTTP fue exitosa.